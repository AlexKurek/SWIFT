\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{color}

%opening
\title{SPH equations}
\author{Matthieu}
\begin{document}

\maketitle

This document does not follow the GADGET notation.\\

\section{Particle definition}
Every particle contains the following information:

\begin{table}[h]
\centering
\begin{tabular}{|l|l|c|l|}
 \hline
 \textbf{Quantity} & \textbf{Type} & \textbf{Symbol} & \textbf{Units} \\
 \hline \hline
 Position & Primary & $\vec{x}$ & $[m]$ \\
 Velocity & Primary &$\vec{v}$ & $[m\cdot s^{-1}]$ \\
 Acceleration & Tertiary &$\vec{a}$ & $[m\cdot s^{-2}]$ \\
 Mass & Primary &$m$ & $[kg]$ \\
 Density & Secondary & $\rho$ & $[kg\cdot m^{-3}]$ \\
 Pressure & Secondary & $P$ & $[kg \cdot m^{-1}\cdot s^{-2}]$ \\
 Internal energy per unit mass & Primary & $u$ & $[m^2 \cdot s^{-2}]$ \\ 
 Energy derivative & Tertiary & $\frac{du}{dt}$ & $[ m^2 \cdot s^{-3}]$ \\
 Correction term & Secondary & $\Omega$ & $[-]$ \\
 Smoothing length & Secondary &$h$ & $[m]$ \\
 Smoothing length derivative & Tertiary &$\frac{dh}{dt}$ & $[m\cdot s^{-1}]$ \\
 Time step & Secondary & $\Delta t$ & $[s]$ \\
\hline
 Artificial viscosity & Primary & $\alpha$ & $[-]$\\
 Artificial conductivity & Primary & $\alpha_u$ & $[-]$\\
 Velocity divergence & Secondary & $\nabla\cdot \vec{v}$ & $[s^{-1}]$ \\
 Internal energy laplacian & Secondary & $\nabla u$ & $[m\cdot s^{-2}]$\\
\hline
\end{tabular} 
\end{table}

Secondary quantities are computed from the primary one in a loop (density loop) over all particle neighbors. Tertiary
ones are computed from secondary ones in another loop (force loop). \\

For optimization purposes, any function of these quantities could be stored. For instance, $1/h$ instead of $h$ or
$\frac{P}{\rho\Omega}$ instead of $\Omega$ may be options worth exploring. \\

The four quantities in the second part of the table are used in improved state-of-the-art implementations of SPH. In a
first approximation, they can be neglected. \\

In what follows, we will use $\vec{r}_{ij} = \vec{x_i} - \vec{x_j}$ and $\hat{r}_{ij} = \vec{r}_{ij}/x|\vec{r}_{ij}|$
to simplify the notation.

\section{Kernel function}

The kernel function can always be decomposed as:

\begin{equation}
 W(\vec{x}, h) = \frac{1}{h^3}f\left(\frac{|\vec{x}|}{h}\right) 
\end{equation}

where $f(q)$ is a low-order polynomial. The simplest possible choice is the cubic-spline kernel which (in 3D) reads
\begin{eqnarray*}
 f(q) &=& \frac{1}{\pi}\left\lbrace \begin{array}{rcl}
                      \frac{1}{4}(2-q)^3 - (1-q)^3 & \mbox{if} & 0 \leq q < 1 \\
		      \frac{1}{4}(2-q)^3 & \mbox{if} & 1 \leq q < 2 \\
		      0 & \mbox{if} & q \geq 2 \\
                     \end{array}
 \right. \\
&=&\left\lbrace \begin{array}{rcl}
    0.31831 -0.477465 q^2+0.238732 q^3& \mbox{if} & 0 \leq q < 1 \\
   0.63662 -0.95493 q+0.477465 q^2-0.0795775 q^3  & \mbox{if} & 1 \leq q < 2 \\
		      0 & \mbox{if} & q \geq 2 \\
                     \end{array}
 \right.
\end{eqnarray*}

The constants here are NOT the constants used in GADGET as we are not following their convention of setting $h$ as the
cut-off value of $W$.\\
Notice that the kernel goes to $0$ when $|\vec{r}_{ij}| = 2h$ in this case. The constant in front of $h$ depends on the
kernel
chosen and to keep it general, we should insert a constant here and say that the interaction only takes place if
$r<\zeta h$ and keep $\zeta$ as a modifiable (compile time) constant. In other words, we can say that $W(x,h)$ is a
function that goes to $0$ if $x > \zeta h$. \\
Coming back to the simplest case, the derivatives of the kernel function are given by:

\begin{eqnarray*}
 \vec\nabla_x W(\vec{x},h) &=& \frac{1}{h^4}f'\left(\frac{|\vec{x}|}{h}\right) \frac{\vec{x}}{|\vec{x}|} \\
 \frac{\partial W(\vec{x},h)}{\partial h} &=&- \frac{1}{h^4}\left[3f\left(\frac{|\vec{x}|}{h}\right) + 
\frac{|\vec{x}|}{h}f'\left(\frac{|\vec{x}|}{h}\right)\right]
\end{eqnarray*}

with

\begin{eqnarray*}
  f'(q)&=& \frac{1}{\pi}\left\lbrace \begin{array}{rcl}
                      3 \left(1-q\right)^2-\frac{3}{4} \left(2-q\right)^2 & \mbox{if} &
0 \leq q < 1 \\
 		      -\frac{3}{4} \left(2-q\right)^2 & \mbox{if} & 1 \leq q < 2 \\
		      0 & \mbox{if} & q \geq 2 \\
                     \end{array}
 \right. \\
&=&\left\lbrace \begin{array}{rcl}
    -0.95493 q + 0.716197 q^2& \mbox{if} & 0 \leq q < 1 \\
   -0.95493+0.95493 q-0.238732 q^2  & \mbox{if} & 1 \leq q < 2 \\
		      0 & \mbox{if} & q \geq 2 \\
                     \end{array}
 \right.
\end{eqnarray*}

In summary, the SPH method uses a low order polynomial $f(q)$ which vanishes for any $q>\zeta$. Those two ``objects''
are linked together and are likely to be changed in different versions of the code. It would be great to be able to
change this without really touching the code. 
Having a compilation option somewhere which activates a given form of $f$ and changes the value of $\zeta$ accordingly
would be great.

\section{First SPH loop (density)}
\label{sec:density}

In the first loop of the algorithm, the secondary quantities of particle $i$ are computed from the primary ones in the
following way:

\begin{eqnarray}
 \rho_i &=& \sum_j m_j W(\vec{r}_{ij}, h_i)\\
 h_i &=& \eta \left(\frac{m_i}{\rho_i} \right)^{1/3}
\end{eqnarray}

where $\eta \approx 1.2$ is a constant. These two equations can be solved iteratively using a Newton-Raphson or
bisection scheme. In practice, the loop is performed over all particles $j$ which are at a distance
$|\vec{r}_{ij}|<\zeta
h$ from the particle of interest. One has to iterate those two equations until their outcomes are stable.\\
Another measure of the accuracy of $h$ is the weighted number of neighbors which (in 3D) reads

\begin{equation}
 N_{ngb} = \frac{4}{3}\pi \left(\zeta h\right)^3 \sum_j W(\vec{r}_{ij},h_i)
\end{equation}

One then change $h$ until an optimal value for $N_{ngb}$ is reached. GADGET uses a bisection algorithm to do so.
The (magical) value of $N_{ngb}$ to obtain is a numerical parameter and its value can be expressed as a function of the
more physically relevant parameter $\eta$. In 3D the relation between those quantities is

\begin{equation}
 N_{ngb} = \frac{4}{3}\pi\left(\zeta \eta\right)^3
\end{equation}

We usually use $N_{ngb} = 48$, which corresponds to a sub-optimal value of $\eta=1.127$. The optimal value should be
$N_{ngb}=57.9$ ($\eta=1.2$) but this is computationally more expensive and the improvement over $N_{ngb}=48$ is not
obvious.\\ 

To increase the convergence rate, one can use the derivative of the density with respect to the smoothing length in the
Newton iterations:

\begin{equation}
 \frac{\partial \rho}{\partial h} = \sum_j m_j \frac{\partial W(\vec{r}_{ij},h_i)}{\partial h}
\end{equation}

This can also give a convergence criterion as this term must be $0$ when the right value oh $h$ has been found.
The derivative of the kernel function has to be computed anyway to obtain a value for the correction term $\Omega_i$.
This term is given by

\begin{equation}
  \Omega_i = 1 + \frac{h_i}{3\rho_i}\sum_j m_j\frac{\partial W(\vec{r}_{ij},h_i)}{\partial h}
\end{equation}

This concludes the first SPH loop in the standard implementation. More complicated quantities such as
$\vec\nabla\times\vec v_i$ or $\vec\nabla\cdot\vec v_i$ are sometimes computed here if they are needed in the force
loop.

\section{Second SPH loop (forces)}
\label{sec:forces}

Once those quantities have been obtained, the force estimation loop can be started.
First, the pressure has to be evaluated evaluated using the equation of state

\begin{equation}
\label{eq:pressure}
 P_i = \rho_i u_i (\gamma - 1)
\end{equation}

where $\gamma$ is the polytropic index. Usually, $\gamma = \frac{5}{3}$.
The second loop is used to compute the accelerations (tertiary quantities). The exact expressions are

\begin{eqnarray}
 \vec{a_i} &=& - \sum_j m_j\left[\frac{P_i}{\Omega_i\rho_i^2}\vec{\nabla_r} W(\vec{r}_{ij}, h_i) +
\frac{P_j}{\Omega_j\rho_j^2}\vec{\nabla_r}W(\vec{r}_{ij}, h_j) \right] \label{eq:acceleration}\\
 \frac{du_i}{dt} &=& \frac{P_i}{\textcolor{red}{\Omega_i}\rho_i^2} \sum_j m_j
(\vec{v_i}-\vec{v_j})\cdot\vec{\nabla_r} W(\vec{r}_{ij}, h_i)
\label{eq:dudt}\\
 \frac{dh_i}{dt} &=& \frac{h_i}{3}\sum_j \frac{m_j}{\rho_j} \left(\vec{v_j} - \vec{v_i} \right)
\cdot\vec{\nabla_r}W(\vec{r}_{ij},
h_i)
\end{eqnarray}

In practice the loop is here performed over all pairs of particles such that $|\vec{r}_{ij}| < \zeta h_i$ or
$|\vec{r}_{ij}| < \zeta
h_j$. In general, the equations are more involved as they will contain terms to mimic the effect of viscosity or
thermal conduction. These terms are pure functions of the properties of particles $i$ and $j$ and are thus very simple
to insert once the code is stabilized.\\

The time steps are computed using the speed of sound inside each ``kernel volume'' surrounding the particle:

\begin{equation}
 c_i = \sqrt{\frac{\gamma P_i}{\rho_i}} = \sqrt{\gamma (\gamma-1)u_i}
\end{equation}

The time step is then given by the Courant relation:

\begin{equation}
 \Delta t_i = C_{CFL} \frac{h_i}{c_i}
\label{eq:dt}
\end{equation}

where the Courant parameter ($C_{DFL}$)usually takes a value between $0.2$ and $0.3$. The integration in time can then
take place. The
leapfrog integrator is usually used as it behaves well when coupled to gravity. \\
In the case where only one global time step is used for all particles, the minimal time step of all particles is reduced
and used. \\

Notice that $h$ has to be recomputed through the iterative process
presented in the previous section at every time step. The time
derivative of the smoothing length only gives a rough estimate of its
change. It only provides a good guess for the Newton-Raphson (or
bisection) scheme.

\section{Time integration}

The usual scheme uses a kick-drift-kick leap-frog integrator. The various sub-steps are:

\textbf{First kick} Kick the particle for the first half-step.

\begin{eqnarray*}
 v_i^{n+1/2} &=& v_i^{n} + \frac{1}{2} a_i^{n}\Delta t^n \\
 u_i^{n+1/2} &=& u_i^{n} + \frac{1}{2} \frac{du_i^n}{dt}\Delta t^n \\
\end{eqnarray*}

\textbf{Particle drift} Advance particles by a full step

\begin{equation*}
 x_i^{n+1} = x_i^n + v_i^{n+{1/2}} \Delta t^n
\end{equation*}

\textbf{Prediction} Predict particles forward in time according to their old ``accelerations''

\begin{eqnarray*}
 v_{i,pred} &=& v_{i,pred} + a_i^{n} \Delta t^n \\
  u_{i,pred} &=& u_{i,pred} \cdot \exp\left(\frac{1}{u_i^n}\frac{du_i^{n}}{dt} \Delta t^n\right)\\
 \rho_i^{n+1} &=& \rho_i^n \cdot \exp\left(\frac{-3}{h_i^n}  \frac{dh_i^{n}}{dt} \Delta t^n \right) \\
  h_i^{n+1} &=& h_i^n \cdot \exp\left(\frac{1}{h_i^n}  \frac{dh_i^{n}}{dt} \Delta t^n \right)   \\
  \Omega_i^{n+1} &=& \Omega_i
\end{eqnarray*}

\textbf{SPH loop 1} Correct $\rho_i^{n+1}$, $h_i^{n+1}$ and $\Omega_i^{n+1}$ if needed using bisection algorithm and the
first SPH loop (Section \ref{sec:density}). \\

\textbf{SPH loop 2} Compute $a_i^{n+1}$, $\frac{du_i^{n+1}}{dt}$ and $\frac{dh_i^{n+1}}{dt}$ using the second SPH
loop (Section \ref{sec:forces}). This loop is ALWAYS performed using the PREDICTED velocity $v_{i,pred}$ and internal
energy $u_{i,pred}$ for BOTH particles. \\

\textbf{New time step} Calculate the next time step.

\begin{equation*}
 \Delta t^{n+1} = C_{CFL} \frac{h_i}{c_i}, \qquad c_i =\sqrt{\gamma (\gamma-1)u_{i,pred}}
\end{equation*}


\textbf{Gravity} Compute accelerations due to gravity. \\

\textbf{Cooling} Compute the change in internal energy due to radiative cooling and heating. \\

\textbf{Second kick} Kick the particle for the second half-step.

\begin{eqnarray*}
 v_i^{n+1} &=& v_i^{n+1/2} + \frac{1}{2} a_i^{\textcolor{red}{n+1}}\Delta t^{\textcolor{red}{n}} \\
 u_i^{n+1} &=& u_i^{n+1/2} + \frac{1}{2} \frac{du_i^{\textcolor{red}{n+1}}}{dt}\Delta t^{\textcolor{red}{n}} \\
 v_{i,pred} &=& v_i^{n+1} \\
 u_{i,pred} &=& u_i^{n+1} \\
\end{eqnarray*}



% A full time step of size $\Delta t$ consists of the
% following sub-steps: \\
% 
% \textbf{First kick} Compute velocity and internal energy at half step.
% 
% \begin{eqnarray*}
%  \vec{v}_i^{n+1/2} &=& \vec{v}_i^n + \textstyle\frac{1}{2}\Delta t^n ~\vec{a}_i\big|^{n-1/2} \\
%  u_i^{n+1/2} &=& u_i^n + \textstyle\frac{1}{2}\Delta t^n ~\frac{du_i}{dt}\big|^{n-1/2}
% \end{eqnarray*}
% 
% \textbf{Drift} Advance time and position by a full step.
% 
% \begin{eqnarray*}
%  t &\leftarrow& t + \Delta t^n \\
%  \vec{x}_i^{n+1} &\leftarrow& \vec{x}_i^{n+1} + \Delta t^n \tilde {\vec{v}}_i^{n}\\
% \end{eqnarray*}
% 
% \textbf{Prediction} Estimate velocity, internal energy and smoothing length at full step
% 
% \begin{eqnarray*}
% \vec{v}_i &\leftarrow& \vec{v}_i + \Delta t \vec{a}_i \\
% u_i &\leftarrow& u_i + \Delta t ~\frac{du_i}{dt} \\
% h_i &\leftarrow& h_i + \Delta t ~\frac{dh_i}{dt} \\
% \end{eqnarray*}
% 
% \textbf{SPH loop 1} Compute $\rho_i$, correct $h_i$ if needed using bisection algorithm and compute $\Omega_i$ using the
% first SPH loop. \\
% 
% \textbf{SPH loop 2} Compute $\vec{a_i}$, $\frac{du_i}{dt}$ and $\frac{dh_i}{dt}$ using the second SPH loop. \\
% 
% \textbf{Gravity} Compute accelerations due to gravity. \\
% 
% \textbf{Cooling} Compute the change in internal energy due to radiative cooling and heating. \\
% 
% \textbf{Second kick} Compute velocity and internal energy at end of step. 
% 
% \begin{eqnarray*}
%  \vec{v}_i &=& \tilde{\vec{v}}_i + \textstyle\frac{1}{2}\Delta t ~\vec{a}_i \\
%  u_i &=& \tilde{u}_i + \textstyle\frac{1}{2}\Delta t ~\frac{du_i}{dt}
% \end{eqnarray*}

\section{Multiple time steps}

In most of the astrophysical applications, the range of time steps of the different particles is huge. In order to
speed-up computations, multiple time steps are used at the cost of a slightly less precise outcome. \\
The interval between the beginning of the simulation $t_{ini}$ and the end $t_{final}$ is decomposed in $2^N$ equal
intervals (In GADGET, $N=29$). The smallest allowed time step is thus
\begin{equation}
 \Delta t_{\min} = \frac{t_{final} - t_{ini}}{2^N}
\end{equation}
\\
The particles are then dispatched in different time bins according to their time steps $\Delta t_i$ (equation
\ref{eq:dt}). A particle $i$ is in bin $n$ if it verifies the condition

\begin{equation}
2^{n-1} \Delta t_{\min}  < \Delta t_i < 2^n\Delta t_{\min} 
\end{equation}

Particles in bin $n=1$ will then all be evolved using $\Delta t_{\min}$ as their time steps, particles in bin $n=2$
will use $2\Delta t_{\min}$ as their time steps, particles in bin $n=3$
will use $4\Delta t_{\min}$ as their time steps and so on. \\

At the beginning of the simulation (i.e. when $t=t_{ini}$), a density loop (section
\ref{sec:density}) is performed to compute the time step of every particle. The particles are then assigned a time bin
and the simulation starts using the smallest populated time bin. \\
At every iteration, a set of time bins will be called \emph{active} and all the particles populating them will be
integrated in time using the equations of section \ref{sec:density} and \ref{sec:forces}.\\
 Over the course of the
simulation, particles will have to move between time bins. Particles are only allowed to move to another bin if this
new bin is active. In other words, particles can always move down the time bin hierarchy but can only go upwards if the
two bins of interest are synchronized.\\

When an active particles is integrated in time, it will probably have to interact with inactive neighbors. The state
of these inactive particles has to be predicted forward in time from the last time they have been active. To do
so, the prediction part of the leapfrog algorithm is used. \\
In other words, the drift and prediction parts of the leapfrog algorithm are performed for all particles whereas the
other parts are only done for the active ones.


\section{Conserved quantities}

The energy, momentum, angular momentum and entropic function are exactly conserved by the equations:

\begin{eqnarray}
E &=&\sum_i m_i\left(\frac{1}{2}|\vec{v_i}|^2+u_i\right)\\
\vec{P} &=&\sum_i m_i \vec{v_i}\\
\vec{L} &=& \sum_i m_i \vec{x_i} \times \vec{v_i}\\ 
A(s) &=& \left(\gamma -1 \right)\sum_i \frac{u_i}{\rho_i^{\gamma - 1}}
\end{eqnarray}

The conservation of those quantities in the code depends on the quality of the time integrator. The leap-frog
integrator of the previous section should preserve these quantities to machine precision.\\
Notice that the entropic function $A(s)$ is not the ``physical'' entropy $s$ but is related to it through a monotonic
function. It is just a more convenient way to represent entropy.
THESE QUANTITIES ARE CONSERVED ONLY IF ONE SINGLE TIME STEP IS USED FOR ALL PARTICLES !!


\section{Improved SPH equations}

The equations \ref{eq:acceleration} and \ref{eq:dudt} correspond to a non-physical system with no viscosity and no
thermal conduction. The physical model can be improved by adding some terms which vary depending on the authors. We
follow here, D. Price and W. Dehnen.
These terms require second derivatives of the fields, which can be expressed in terms of the second derivative of $W$.
However, due to discreteness effects computing the derivatives of a field using $\partial^2_{rr}W$ is very noisy even
when using high-order polynomial. For this reason a wrong second derivative is used based on the first derivative. We
first introduce $F(\vec{r}_{ij},h_i)$, the scalar part of the gradient of $W$. It is defined as

\begin{equation}
 \nabla_r W(\vec{r}_{ij},h_i) = F(\vec{r}_{ij},h_i) \hat{r}_{ij}
\end{equation}

which in 3D implies that

\begin{equation}
 F_{ij}(h_i) \equiv F(\vec{r}_{ij},h_i) = \frac{1}{h_i^4}f'\left(\frac{|\vec{r}_{ij}|}{h_i}\right)
\end{equation}

where $f$ is the dimensionless part of the kernel introduced earlier. For symmetry reasons, we will use

\begin{eqnarray}
 \bar{F}_{ij} &=& \frac{1}{2} \left(F_{ij}(h_i) + F_{ij}(h_j)\right) \\
	      &=& \frac{1}{2h_i^4}f'\left(\frac{|\vec{r}_{ij}|}{h_i}\right) +
\frac{1}{2h_j^4}f'\left(\frac{|\vec{r}_{ij}|}{h_j}\right) \\
\end{eqnarray}

in the equations. A decent place-holder for the second derivative of $W$ is then $-2F_{ij}/|\vec{r}_{ij}|$.

\subsection{Artificial viscosity}

 Artificial viscosity can be introduced by adding a term to both equation \ref{eq:acceleration} and \ref{eq:dudt}:

\begin{eqnarray}
  \vec{a_i} &\stackrel{visc}{=}& 2\sum_j m_j \frac{\alpha v_{sig}\left(\vec{v}_i -
\vec{v}_j\right)\cdot\hat{r}_{ij}}{\left(\rho_i + \rho_j\right)}\hat{r}_{ij}\cdot \bar{F}_{ij} \label{eq:visc}\\
 \frac{du_i}{dt} &\stackrel{visc}{=}& -\sum_j \frac{m_j}{(\rho_i + \rho_j)} \alpha
v_{sig}\left[\left(\vec{v}_i-\vec{v}_j\right)\cdot\hat{r}_{ij}\right]^2 \bar{F}_{ij}
\end{eqnarray}

where $\alpha$ is the dimensionless artificial viscosity and

\begin{equation}
 v_{sig} = \begin{cases}
	    \frac{1}{2}\left[c_i + c_j - \beta\left(\vec{v}_i-\vec{v}_j\right)\cdot\hat{r}_{ij} \right] &
\mbox{if} \quad \left(\vec{v}_i-\vec{v}_j\right)\cdot \hat{r}_{ij} < 0\\
            0 & \mbox{if} \quad \left(\vec{v}_i-\vec{v}_j\right)\cdot \hat{r}_{ij} > 0
            \end{cases}
\end{equation}

corresponds to the maximal (average) signal speed between pairs of particles.
GADGET uses $\alpha=1$ (but can be changed) and $\beta=3\alpha$ (fixed). In addition, the Balsara switch is used. \\

Modern implementations of SPH use a variable viscosity $\alpha_i$ for each particle. The idea behind this is to switch
of viscosity in the part of the flows where the fluid is dissipation-less and to switch it on in shocks. This is done by
using a shock detector and then a slow decay of the viscosity with time. Following Price, we use

\begin{eqnarray}
 \frac{d\alpha_i}{dt} &=& \left(\alpha_{max}-\alpha_i\right)\mathcal{S}~+\frac{(\alpha_i-\alpha_{min})c_i\sigma}{h_i}\\
 \mathcal{S} &=& \max\left(0, -\nabla\cdot \vec{v}_i \right)
\end{eqnarray}

with (usually) $\alpha_{max} = 2$, $\alpha_{min} = 0.1$ and $\sigma=0.1$. The $\alpha$ term in (\ref{eq:visc}) is then
replaced by $\bar\alpha = \frac{1}{2}(\alpha_i + \alpha_j)$. The same applies to $\beta$ which is now, $\beta =
3\bar\alpha$.\\
The divergence of the velocity field can be computed in the density loop and the exact expression is

\begin{equation}
 \label{eq:div_v}
 \nabla\cdot v_i = \frac{1}{\rho_i}\sum_j m_j \left(\vec{v}_j - \vec{v}_i\right)\cdot \nabla_r W(\vec{r}_{ij},h_i) 
\end{equation}

\subsection{Thermal conductivity}

The thermal conductivity  which dissipates energy at discontinuities in the energy field can be modeled by adding
another term to the internal energy evolution equation (\ref{eq:dudt}). 

\begin{equation}
 \frac{du_i}{dt} \stackrel{cond}{=} - \sum_j \alpha_u v_{sig,u}\left(u_i - u_j\right)\bar{F}_{ij}
\end{equation}

This time, the signal velocity must vanish when we are dealing with a contact discontinuity as no energy should flow
between the two regions in this case. A good choice is to use

\begin{equation}
 v_{sig,u} = \sqrt{\frac{2|P_i-P_j|}{\rho_i+\rho_j}}
\end{equation}

Once again, the $\alpha$-term is made to decay far from any discontinuity. In this case, the equation reads

\begin{eqnarray}
 \frac{d\alpha_{u,i}}{dt} &=&  \mathcal{S}_u - \frac{\alpha_{u,i}c_i\sigma}{h_i}  \\
 \mathcal{S}_u &=& \frac{h_i \nabla^2 u_i}{10}
\end{eqnarray}

where again $\sigma=0.1$ as in the viscosity terms. As in the velocity divergence case, the laplacian of $u$ can be
computed in the density loop and reads

\begin{equation}
 \nabla^2 u_i = \frac{2}{\rho_i} \sum_j m_j \left(u_j - u_i\right) \frac{F_{ij}}{|\vec{r}_{ij}|}
\end{equation}


\end{document}
